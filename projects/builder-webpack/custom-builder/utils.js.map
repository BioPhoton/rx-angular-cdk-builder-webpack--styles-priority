{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../libs/builder-webpack/custom-builder/utils.ts"],"names":[],"mappings":";;;AAAA,+BAAiD;AACjD,yDAGmC;AAEnC,8CAAgD;AAChD,4CAAkD;AAClD,yBAAyB;AACzB,2BAA8C;AAE9C,SAAgB,iBAAiB,CAC/B,OAAuB,EACvB,aAAqB;IAErB,MAAM,MAAM,GAAG,kCAAsB,CAAC,aAAa,CAAC,CAAC;IACrD,OAAO,WAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC;AAChD,CAAC;AAND,8CAMC;AAED,SAAgB,YAAY,CAC1B,OAAU,EACV,OAAuB;IAEvB;;;;;;;;;UASM;IACN,MAAM,iCAAiC,GAAG,SAAE,CAAC,OAAO,CAAC,CAAC;IACtD,MAAM,cAAc,GAAG,iCAAiC,CAAC,IAAI,CAC3D,qBAAS,CAAC,CAAC,OAAO,EAAE,EAAE;QACpB,OAAO,eAAe,IAAI,OAAO;YAC/B,CAAC,CAAC,iBAAiB,CAAC,OAAO,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;YACtD,CAAC,CAAC,SAAE,CAAC,EAAE,CAAC,CAAC;IACb,CAAC,CAAC,CACH,CAAC;IACF,OAAO,UAAG,CAAC,cAAc,EAAE,iCAAiC,CAAC,CAAC,IAAI,CAChE,eAAG,CACD,CAAC,CAAC,aAAa,EAAE,aAAa,CAAC,EAAE,EAAE,CAChC,kBAAkB,CACjB,aAAoB,EACpB,aAAoB,CACJ,CACrB,CACF,CAAC;AACJ,CAAC;AA/BD,oCA+BC;AAED,SAAgB,kBAAkB,CAChC,iBAA6B,EAC7B,kBAA8B,EAC9B,kBAAuB,EAAE,EACzB,cAAc,GAAG,KAAK;IAEtB,MAAM,oBAAoB,GAAG,MAAM,CAAC,OAAO,CAAC,kBAAkB,CAAC;SAE5D,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,KAAK,SAAS,CAAC;SAC3C,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,iCAAM,GAAG,KAAE,CAAC,GAAU,CAAC,EAAE,KAAK,IAAG,EAAE,EAAE,CAAC,CAAC;IACxE,MAAM,kBAAkB,mCACnB,iBAAiB,GACjB,oBAAoB,CACxB,CAAC;IACF,qBAAqB;IAErB,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAjBD,gDAiBC;AAED,SAAgB,aAAa,CAAC,IAAY;IACxC,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;QACxB,8BAA8B;QAC9B,OAAO,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC;YAC1B,eAAe,EAAE;gBACf,MAAM,EAAE,UAAU;aACnB;SACF,CAAC,CAAC;KACJ;IAED,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;IAC7B,kDAAkD;IAClD,kDAAkD;IAClD,EAAE;IACF,oBAAoB;IACpB,8BAA8B;IAC9B,yBAAyB;IACzB,4BAA4B;IAC5B,mCAAmC;IACnC,yBAAyB;IACzB,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC;IAE9C,OAAO,YAAY,CAAC;AACtB,CAAC;AAvBD,sCAuBC;AAED;;GAEG;AACH,SAAgB,QAAQ,CAAC,IAAY;IACnC,IAAI,eAAU,CAAC,IAAI,CAAC,EAAE;QACpB,OAAO,iBAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACpC;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AALD,4BAKC;AAED,SAAgB,kBAAkB,CAAC,IAAY;IAC7C,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IAEzC,OAAO,WAAW,CAAC;AACrB,CAAC;AAJD,gDAIC;AAED;;;;GAIG;AACH,SAAgB,cAAc,CAAC,OAAe,EAAE,EAAE,QAAiB;IACjE,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;QAChC,8BAA8B;QAC9B,OAAO,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC;YAC1B,OAAO,EAAE,QAAQ;YACjB,eAAe,EAAE;gBACf,MAAM,EAAE,UAAU;gBAClB,KAAK,EAAE;oBACL,MAAM;iBACP;aACF;SACF,CAAC,CAAC;QAEH,6BAA6B;QAC7B,MAAM,aAAa,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;QAChD,MAAM,EAAE,eAAe,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,aAAa,CAAC,UAAU,CAClE,QAAQ,CACT,CAAC;QACF,IAAI,OAAO,IAAI,KAAK,EAAE;YACpB,aAAa,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;SAC5C;KACF;AACH,CAAC;AAtBD,wCAsBC;AAED,SAAgB,aAAa,CAAI,CAAiB;IAChD,IAAI,sBAAc,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE;QAC7B,OAAQ,CAA2B,CAAC;KACrC;IACD,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC,CAAe,CAAC;AAC1C,CAAC;AALD,sCAKC;AAED,SAAgB,OAAO,CAAC,GAAW;IACjC,OAAO,EAAE,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;AAC7B,CAAC;AAFD,0BAEC","sourcesContent":["import { from, Observable, of, zip } from 'rxjs';\r\nimport {\r\n  BuilderContext,\r\n  targetFromTargetString,\r\n} from '@angular-devkit/architect';\r\nimport { JsonObject } from '@angular/compiler-cli/ngcc/src/packages/entry_point';\r\nimport { map, switchMap } from 'rxjs/operators';\r\nimport { hasOwnProperty } from 'tslint/lib/utils';\r\nimport * as fs from 'fs';\r\nimport { existsSync, readFileSync } from 'fs';\r\n\r\nexport function fromTargetOptions(\r\n  context: BuilderContext,\r\n  browserTarget: string\r\n): Observable<JsonObject> {\r\n  const target = targetFromTargetString(browserTarget);\r\n  return from(context.getTargetOptions(target));\r\n}\r\n\r\nexport function mergeOptions<T>(\r\n  options: T,\r\n  context: BuilderContext\r\n): Observable<T> {\r\n  /*\r\n      The way the options are resolved when executing a target is\r\n      - by taking the default options object\r\n      - then overwriting values from the configuration used (if any)\r\n      - browserTarget: options\r\n      - then overwriting values from the Angular CLI overrides object built from command line arguments\r\n\r\n      This is then validated against the schema of the builder, and only then,\r\n      if valid, the context will be created and the builder itself will execute.\r\n      */\r\n  const optionsSourceOverriddenByConsole$ = of(options);\r\n  const optionsRemote$ = optionsSourceOverriddenByConsole$.pipe(\r\n    switchMap((options) => {\r\n      return 'browserTarget' in options\r\n        ? fromTargetOptions(context, options['browserTarget'])\r\n        : of({});\r\n    })\r\n  );\r\n  return zip(optionsRemote$, optionsSourceOverriddenByConsole$).pipe(\r\n    map(\r\n      ([remoteOptions, sourceOptions]) =>\r\n        (mergeTargetOptions(\r\n          remoteOptions as any,\r\n          sourceOptions as any\r\n        ) as unknown) as T\r\n    )\r\n  );\r\n}\r\n\r\nexport function mergeTargetOptions(\r\n  targetOptionsBase: JsonObject,\r\n  targetOptionsApply: JsonObject,\r\n  mergeStrategies: any = {},\r\n  replacePlugins = false\r\n): { [key: string]: any } {\r\n  const parsedOptionsToApply = Object.entries(targetOptionsApply)\r\n\r\n    .filter(([_, value]) => value !== undefined)\r\n    .reduce((acc, [key, value]) => ({ ...acc, [key as any]: value }), {});\r\n  const mergedTargetOption = {\r\n    ...targetOptionsBase,\r\n    ...parsedOptionsToApply,\r\n  };\r\n  // special cases here\r\n\r\n  return mergedTargetOption;\r\n}\r\n\r\nexport function resolveExport(path: string): any {\r\n  if (path.endsWith('.ts')) {\r\n    // Register TS compiler lazily\r\n    require('ts-node').register({\r\n      compilerOptions: {\r\n        module: 'commonjs',\r\n      },\r\n    });\r\n  }\r\n\r\n  const result = require(path);\r\n  // If the user provides a configuration in TS file\r\n  // then there are 2 cases for exporting an object.\r\n  //\r\n  // The first one is:\r\n  // `module.exports = { ... }`.\r\n  // And the second one is:\r\n  // `export default { ... }`.\r\n  // The ESM format is compiled into:\r\n  // `{ default: { ... } }`\r\n  const resultExport = result.default || result;\r\n\r\n  return resultExport;\r\n}\r\n\r\n/**\r\n * Ensures the file exists before reading it\r\n */\r\nexport function readFile(path: string): string {\r\n  if (existsSync(path)) {\r\n    return readFileSync(path, 'utf-8');\r\n  }\r\n  return '';\r\n}\r\n\r\nexport function resolveFileContent(path: string): string {\r\n  const fileContent = readFile(path) || '';\r\n\r\n  return fileContent;\r\n}\r\n\r\n/**\r\n * check for TS node registration\r\n * @param file: file name or file directory are allowed\r\n * @todo tsNodeRegistration: require ts-node if file extension is TypeScript\r\n */\r\nexport function tsNodeRegister(file: string = '', tsConfig?: string) {\r\n  if (file && file.endsWith('.ts')) {\r\n    // Register TS compiler lazily\r\n    require('ts-node').register({\r\n      project: tsConfig,\r\n      compilerOptions: {\r\n        module: 'CommonJS',\r\n        types: [\r\n          'node', // NOTE: `node` is added because users scripts can also use pure node's packages as webpack or others\r\n        ],\r\n      },\r\n    });\r\n\r\n    // Register paths in tsConfig\r\n    const tsconfigPaths = require('tsconfig-paths');\r\n    const { absoluteBaseUrl: baseUrl, paths } = tsconfigPaths.loadConfig(\r\n      tsConfig\r\n    );\r\n    if (baseUrl && paths) {\r\n      tsconfigPaths.register({ baseUrl, paths });\r\n    }\r\n  }\r\n}\r\n\r\nexport function coercePromise<T>(p: Promise<T> | T): Promise<T> {\r\n  if (hasOwnProperty(p, 'then')) {\r\n    return (p as unknown) as Promise<T>;\r\n  }\r\n  return Promise.resolve(p) as Promise<T>;\r\n}\r\n\r\nexport function readDir(dir: string): string[] {\r\n  return fs.readdirSync(dir);\r\n}\r\n\r\n"]}